# 関数があるスタックマシン上での完全なGCについて

non-moving-gcを読む前に、スタックマシンの完全なGC

レコードをアロケーション可能なスタックマシンを考えます。
命令は配列上にならんでいます。
レジスタは、プログラムカウンタと、スタックポインタ、ベースポインタがあります。
レコードをアロケーションする場合は、単純にアロケータにサイズを渡すとそのサイズのアドレスがスタックに積まれてかえってきます。
このスタック情報のポインタはおそらくstoreしたあと、参照しながらレコードの値を保存する事になるでしょう。

	let rec f x y =
		let a = x + 1 in
		let b = y + 2 in
		let r = {a=a;b=b} in
		r


スタック内容

	引数変数1　リターン値を入れる場所
	引数変数2
	引数変数3
	引数変数4
	ローカル変数5
	ローカル変数6
	ローカル変数7
	ローカル変数8
	スタックポインタの値
	ベースポインタの値
	リターンアドレス


スタックマシンのベリファイ





こんな感じになります。

	static int[] malloc();
    descriptor: ()[I
    flags: ACC_STATIC
    Code:
      stack=1, locals=1, args_size=0
         0: ipush          10
         2: newarray       int
         4: astore_0
         5: aload_0
         6: areturn
      LineNumberTable:
        line 15: 0
        line 16: 5	

メモリ配置プログラムは以上のようになり、アドレスの4が戻ってくるアドレスです。
ここのアドレスの時のスタック状態は分かるはずなのです。可変長引数の場合は配列に入れる等になると思いますが。

mark_and_sweepでは、GCのみ作ってみた訳ですが、ここでは、関数のプログラムを配列上に配置し、
リターンアドレスをスタックに保存するような仮想機械をつくります。

そして、現状のスタック情報から分かるようにします。

マルチスレッドは考えません。

c ::= push i | load i | store i1 i2 | call i | ret | add | mul | bne i | jmp i
PC ::= i
BP ::= i
SP ::= i
H ::= ヒープ
vm ::= (i array, c array, PC, BP, SP, H)


	let push = 1
	let load = 2
	let enter = 3
	let leave = 4
	let store = 5
	let call = 6
	let ret = 7
	let add = 8
	let mul = 9
	let bne = 10
	let jmp = 11



	命令途中だと、スタック状態は曖昧であるのが困る。
	しかし、シングルスレッドならメモリ呼び出しの履歴からあきらかである。
	このへんマルチスレッドだと難しいのでnon-moving-bitmap-gcを読むのが一番だけど、理解が足りてないと分からないのでシングルスレッドの事を考える。

	メモリ割り当てが必要なのは関数だけだけど、そのああ。ベースポインタ