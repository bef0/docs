# Objective-CのARCに似たGCの方式の提案

## 1. モチベーション

メモリ管理手法としては、手動管理が速いですが開発が大変です。
参照カウンタ方式は、カウントのコストが気になります。循環参照を検査する事で解放は可能ですが、循環参照の問題もあります。
ガーベジコレクションはメモリ空間が広がるとGC時間が肥大します。
プロセス呼び出しをパイプで繋ぎ、データをやり取りすれば、プロセス単位でメモリは解放されるので、保守的なGCでも十分でしょうし、GCをそもそも使う必要がないかもしれませんが、プロセスの起動コストとデータのシリアライズとデシリアライズのコストが気になります。
ErlangのようなマルチVMのアクターモデルは、素晴しいですがメッセージのやり取りをする必要はありません。
Objective-CのAutoReleasePoolは面白いアイディアですが、参照カウンタ方式です。
線形型や、オーナーシップは型によってリソースの解放を保証しますが、型を意識して書くプログラムは面倒くさいものがあります。
Golangのgoルーチンや、Rustのspwawnはメモリ空間を分けますが並列化の機能です。並列化にはスレッド起動かアクターのようなやり取りが必要で高コストです。
OCamlの多相的型推論はレベルを用いて解決していますが、その考えをオートリリースプールに応用出来るかもしれません。
なんとか、マイナーGCを小さい空間で行う高速なアルゴリズムが作れない物かと思う訳です。

## 2. アイディア

新しいメモリ空間のみを作り計算し、終わったら計算結果をルート集合としてガーベジコレクションを行うようなことが出来ればいいのではないかという漠然とした考えが生まれました。

参照は出来るが、結果のコピーが必要な場合は、関数を通して取得します。

プログラムの種類にもよりますが例えば、ゲームの場合は、フレームごとにキャラクターが移動します。
この場合、フレームごとに前の世代を参照しつつ新しいデータを更新して行けばGCを毎フレームごとに計算しながら行う事が出来そうです。

複数パスに別れるような計算では、段階ごとに作成したデータを次のパスへ渡すポイントでコピーするようにすれば、奇麗なGCが行えそうです。
ヒープのサイズは64bitの時代なので1Gクラスに取れるようにして置けばほぼ問題なく動作させる事が出来る場合が大半でしょう。
しかし、単純なリストだけでも美味くやればそれなりの物が作れるかもしれません。

というような漠然としたアイディアを実装するアルゴリズムを考えてみようと思います。

おそらく２つのアルゴリズムが考えられそうです。

1. レベルで領域を管理する。
2. 領域を複数持ちIDを持って管理する。

今回はまず1のレベルで領域を管理するアルゴリズムを提案します。

## 3. アルゴリズム

新しい計算モデルでは、計算空間を作成する関数を作りここで、新しいヒープ空間をつくります。

スレッドに近いのですが、ヒープを別空間に作ります。

ヒープ空間を作ると、そこで作成するオブジェクトは別空間で生成されます。

ヒープ空間を使った計算が終わったら、計算結果をルート集合としてガーベジコレクションを行います。
ただし、検索するのは新しい空間のみとします。

これにより、返却されるデータは全て、元の空間にコピーされますが、元のデータ空間は最小限の変更しかないのでマイナーGCが実行されるのに等しくなります。

新しい領域は、データにレベルを持たせる事で作成します。グローバル変数にlevelを持ち、新しい領域に入ったらカウントアップします。
メモリアロケーション関数はlevelをオブジェクトに持たせます。

GCが起きた場合は、levelを見て、現在レベルより低いレベルのオブジェクトまでは見に行きません。
また、スイープの段階でも、現在レベルのみ解放します。
新しい計算領域では、元のレベルから受け取ったデータを参照は出来ますが変更はできません。
なので、外から参照される事はありません。

計算が終わったら、計算結果をルート集合としてマークします。スイープし、残ったオブジェクトはレベルを下げます。
こうすると結果のみが残ります。最後にグローバルのレベルを元に戻して終わります。

[mark_and_sweep](../mark_and_sweep)に新たに、ヒープを作れる用にするだけです。

heap_listはから

				level = 1
    			heap_list -> null
                world_list -> null

メモリ割り当てが進む

				level = 1
    			heap_list -> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null
                world_list -> null

新しい領域に入ると、新しい領域に入った時のリストのトップを保存する。

				level = 2
    			heap_list -> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null

新しい領域で計算する。

				level = 2
    			heap_list -> (l2 5)->(l2 6)->(l2 7)->
                               | |           ^
                               | |           |
                               | +-----------+
                               v
    			-> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null


計算が終わったので5の値を返したいので、5をルートとしてマークする。
このとき、レベルが5のレベルより小さいポインタは親領域なのでマークしない。

				level = 2
    			heap_list -> (l2*5)->(l2 6)->(l2*7)->
                               | |           ^
                               | |           |
                               | +-----------+
                               v
    			-> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null

マークが終わったら、スイープをする。スイープは現状のレベルを1つ下げて、レベルが高いものだけマークされている物を残して現状レベルに下げ、マークされていない物は消す。

				level = 1
    			heap_list -> (l1 5)  (l2x6)  (l1 7)->
                               | |           ^
                               | |           |
                               | +-----------+
                               v
    			-> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null

## 実装

gc.cを参照。

todo: diffを取ってみる。

## 参考文献

- AST2 線形型

    http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/HTML/c4154.html#simple-linear-objects

- Rust オーナーシップ

    https://doc.rust-lang.org/book/ownership.html

- Objective-C ARCによるメモリ管理 Saturday, December 31st, 2011

    http://cx5software.sakura.ne.jp/blog/2011/12/31/objective-c-memory_management_by_arc/

- 微酔半壊: copying GCに対する改良 2007年04月01日

    http://smpl.seesaa.net/article/37446952.html

- 微酔半壊: Copying Garbage Collector 2007年03月17日

    http://smpl.seesaa.net/article/36160135.html

- How OCaml type checker works -- or what polymorphism and garbage collection have in common

    http://okmij.org/ftp/ML/generalization.html
