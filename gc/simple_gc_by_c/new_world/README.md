# Objective-CのARCに似たGCの方式の提案

GC時間は使う空間が広がれば広がる程長くなります。
参照カウンタ方式はカウンタの更新にコストがかかります。

ここでは、新しいメモリ空間のみを作りその中で計算をし計算が終わったら、
参照は出来るが、結果のコピーが必要な場合は、関数を通して取得するようなプログラミングモデルを提案します。

プログラムの種類にもよりますが例えば、ゲームの場合は、フレームごとにキャラクターが移動します。
この場合、フレームごとに前の世代を参照しつつ新しいデータを更新して行けばGCを毎フレームごとに計算しながら行う事が出来ます。

また、複数パスに別れるような計算では、段階ごとに作成したデータを次のパスへ渡すポイントでコピーするようにすれば、奇麗なGCが行えそうです。ヒープのサイズは64bitの時代なので1Gクラスに取れるようにして置けばほぼ問題なく動作させる事が出来る場合が大半でしょう。

というような漠然としたアイディアはあるので、それを実際に作ってみようと思います。


新しい計算モデルでは、計算空間を作成する関数を作り、コールバックを渡して実行します。

ここで、新しいヒープ空間のみをつくります。要するにスレッドに近いのですが、
ヒープのみ、別空間が使われます。

コールバック関数はポインタを１つ返す事が出来て、ここに返すデータを全て入れて返します。
close_heap関数では、元のヒープにコピーする動作が行われます。

	void* newworld(void*(*f)(void* data), void* data){
		open_heap();
		return close_heap(f(data));
	}

これにより、返却退れるデータは全て、元の空間にコピーされますが、元のデータ空間は最小限の変更しかないのでマイナーGCが実行されるのに等しくなります。
このような仕組みは、広大なメモリ空間を持つ64bit CPUでは特に有効です。
コピーはコピー関数を渡す事が可能で、その方がより高速に動作します。
しかし、レコードごとにビットマップを持つ場合は、コピーは動的に可能です。
ここではレコードがビットマップを持つ事にします。


[mark_and_sweep](../mark_and_sweep)に新たに、ヒープを作れる用にするだけのはずですはい。

heap_listはから

				level = 1
    			heap_list -> null
                world_list -> null
メモリ割り当てが進む

				level = 1
    			heap_list -> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null
                world_list -> null

新しい領域に入ると、新しい領域に入った時のリストのトップを保存する。

				level = 2
    			heap_list -> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null

新しい領域で計算する。

				level = 2
    			heap_list -> (l2 5)->(l2 6)->(l2 7)->
                               | |           ^
                               | |           |
                               | +-----------+
                               v
    			-> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null


計算が終わったので5の値を返したいので、5をルートとしてマークする。
このとき、レベルが5のレベルより小さいポインタは親領域なのでマークしない。

				level = 2
    			heap_list -> (l2*5)->(l2 6)->(l2*7)->
                               | |           ^
                               | |           |
                               | +-----------+
                               v
    			-> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null

マークが終わったら、スイープをする。スイープは現状のレベルを1つ下げて、レベルが高いものだけマークされている物を残して現状レベルに下げ、マークされていない物は消す。

				level = 1
    			heap_list -> (l1 5)  (l2x6)  (l1 7)->
                               | |           ^
                               | |           |
                               | +-----------+
                               v
    			-> (l1 4)->(l1 3)->(l1 2)->(l1 1)->null

