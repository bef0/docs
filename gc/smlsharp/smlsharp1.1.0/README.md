# SML# 1.1.0のランタイムについて

ずっとソースを読んでいたのでまとめてみたいと思います。

SML#の素晴しい点はCとの相互運用性です。
特に古いSML#1.1.0のソースコードはCだけで完全なGCを実現出来ます。



2.0.0はLLVMに対応したので、LLVMも必要になります。


エラーとスプレーとOBスタック

エラーはエラー出力をまとめた物で、エラーやデバッグやワーニングやノーティスやシステムエラー等を出力する機能があります。
スプレーはOSのメモリをスワップするように、
特に最後にアクセスした周辺のデータの検索が高速になるように設計されています。
例外は例外をsetjmpとlongjmpを使って実装してあり、システム用の例外が登録されています。
スプレーはハッシュマップですが、興味深いのはCだけでそれなりに関数プログラミングしているところです。マップは様々なデータを含む事が出来るべきです。これをMLのファンクターのように、C言語のqsortのように拡張している点が楽しいです。
C++ならSTLのようにテンプレートを使うわけですが。

OBスタックはヒープデータを保存するスタック構造を持ってます。
クロージャをコールバックで登録したら構造体を保持しないと行けない。
GCに含めないデータ構造も扱えないと行けない。
OBスタックにはマロック、フリーがあり、追加し、削除し、トラバースする機能があります。

コントロールとオブジェクトスペース、ヒープ、オブジェクトがある。

コントロールは生死管理をします。フレームの作成や削除などを行います。
マルチスレッドならスレッドのコンテキストを管理します。
GC時のストップザワールドも含まれます。


オブジェクトスペースはGC追加されたルート集合やmallocしたデータを管理します。

GC用の基本的なマークするためのトラバースや、マークのトラバースでスタックが溢れないようにするためのmalloc_stackスタックも含まれます。オブジェクトのヘッダ部文にはリスト構造を作ったりマークビットがありこれを利用してリストを作ったりマークしたりします。
ルート集合にはコントロールのフレームも含まれます。

ヒープは、メモリの確保とガーベジコレクションをオブジェクトスペースから切り離した物です。

オブジェクトは例えば、レコードの作成や、文字列の作成、配列の作成等を行います。


これらを初期化するのがinit.cです。パラメータによってメモリ容量を変えたり出来ます。

prim.cはライブラリ関数が含まれています。
ランタイムにはメイン関数が含まれていて、SMLmainを呼び出します。

何をしたいのかというと、非常に単純なC用の完全なGCが出来るプログラムを作りたいということです。

そのために、ヒープを独自で管理し、フレームを管理し、ルート集合を管理出来ると嬉しい訳です。
ルート集合に何でもかんでも突っ込むよりも、フレームとルート集合は分離してあると嬉しいですよね。


