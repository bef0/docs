# 超Prologのページ

ここでは、次世代のPrologについて考える。
実はライブラリとして作成できることもあるので、考察した結果ライブラリで出来るのであれば、ライブラリとして可能として分類してみよう。

## モチベーション

計算機科学で用いられる推論規則を考えるのにPrologはかなり向いている。
しかし、Prologでは足りない機能が複数存在しているため、Prologそのもので完全に推論規則を再現することは難しい。
そこで、ここでは、新しい論理型言語を作ることを考えてみる。


## ライブラリとして実装できるもの

### 水平線構文。推論規則の図のように書きたい。sequent library

Prologを新たに作らなくてもterm_expansionで可能だ

    :- op(1200,xfx,--).
    term_expansion(A--B,B:-A).

    R is A + B
    --%--------- (E-Add)
    A + B ---> R.

と記述すればよい。

### 置換構文 a[b/c]のように書くことができるようにしたい。sequent library

Prologにはa[]のような演算子は存在しないので、a/[b/c]のように書くことで実現する。
term_expansionを使うことで置き換えも可能だろう。

### 評価文脈 E[a b]のように書きたい。 sequent library

置換構文同様にE/[a b]のように書くことで評価文脈を実現できるはず。

### 評価文脈を構文定義のように書いて実現したい sequent library

    e ::= [] | e + m | m + e | e - m | m - e.

ここから、評価文脈を表す物を作れると嬉しい。しかし、難しそうだ。

### リスト構文は例えば、Γ,x=1,y=2のように書きたい。 sequent library

これの問題は、カンマの結合順を反転したいということにある。
カンマの結合順を反転させてしまうと他の述語の結合順が (((a,b),c),d)のようになってしまうので、リスト的に扱うのが難しくなる。
しかし、((a,b),c)の意味は同じなので何とかなるのではないだろうか。

### 変数名によるバリデータ登録 sequent library

Fortlanでは、変数名から暗黙的に型がつく。
同様に、操作的意味論では変数名から型を推論するように記述する。
変数名から型名を推論できる機構を作成し、バリデーションが可能となると嬉しい。

実現方法は、term_expansionによって、--などの述語を使った場合に、変数名としてt1やt2などを使っている場合に、
T1,T2などに変換し、値を返す場合もありうるので、varではない場合に、値をチェックするようにrtgの拡張として構文定義された集合としてチェックするようにすると良さそう。

## :- をイコールにする。 functional library

    a :- nl.

を

    a = ni.

と書けるようにする。述語=はそもそも定義できないので出来る気もする。というか出来た。

    term_expansion(A=B,(A:-B)).
    a = nl.
    :- write(a),a.
    :- halt.

問題は演算子の優先順位と、関数ではないので値を返すわけではないことだ。
=を使うと関数を定義するように述語が定義できて、述語を関数のように呼ぶことができるとよいのかなぁ。

    add(A,B) = R is A + B, R.

## ネストした関数のように扱いたい functional library

出力が一番後ろにある述語をネストしたい。
以下のようにネストした述語を関数的に扱う述語を作れば出来る。

    run({T},T).
    run(T,R):-compound(T),T=..[Name|P],maplist(run,P,P_),T_=..[Name|P_],call(T_,R).
    run(A,A).
    run(T):-compound(T),T=..[Name|P],maplist(run,P,P_),T_=..[Name|P_],call(T_).
    run(_).
    +(A,B,R) :- R is A + B.
    :- run(writeln(maplist({[A,B]>>(B is A * 10)},{[1,2,3]}))).
    :- halt.

## 言語機能の拡張が必要なもの

### 水平線構文。推論規則の図のように書きたい。sequent language

    A + B ---> R :- R is A + B.

を以下のように書きたい。

    R is A + B
    ------------ (E-Add)
    A + B ---> R


### カンマをなくす。 複数空白文字でカンマの役割としたい。 sequent language

    A ---> A_   B ---> B_   R is A_ + B_
    --%--------------------------------
    A + B ---> R.

のように記述したい。カンマの代わりに空白２文字あるいは３文字以上を使えると良いのではないだろうか。

### ダッシュを使いたい lexical language

    A ---> A'   B ---> B'   R is A' + B'
    --%--------------------------------
    A + B ---> R.

と書きたい。

## ドットレスにしたい。 sequent language

現状のPrologは述語定義の最後に.を書く必要があるが、.は書かなくても良いようにしたい。たとえば、空行が含まれれば.の意味とするのはどうか。

    A ---> A_, B ---> B_, R is A + B
    --%--------------------------------
    A + B ---> R.

のように書けるわけだけど、最後のドットが気になる。

    A ---> A_, B ---> B_, R is A + B
    --%--------------------------------
    A + B ---> R

と書きたい。

### a[], a{}のような構文 language

    :- op(100,xfy,'[]').
    :- op(100,xfy,'{}').

上記のように定義することで、 a[]は '[]'(a)、 a{}は '{}'(a)、 a[b,c]は'[]'(a,(b,c))などと定義できるとよいのではないか。

## 関数適用構文を導入したい。sequent language

    Γ |- A ---> (λX->Y), Γ |- B ---> B_,
    --%--------------------------------
    Γ |- A B ---> Y/[X/B_].

のように書くために、`A B`と書けるようにしたい。

演算子名は''あるいは、'@','$'が良いと考える。
'@'はClean Bookで用いられたところによる。
'$'はHaskellの$でもあり、FLOPSのPrologの論文によるところもある。

    :- op(100,xfy,'').

などと定義することで、様々な記法に対応できるようになるのではないかと思う。
lambda prologなどで実装されている。

## 変数を小文字にする language

ErlangはPrologに似て変数が大文字だがElixerは小文字が変数だ。
Prologは多くの言語を扱うメタな言語だ。したがって、大文字と小文字は逆のほうが良いのかもしれない。
しかし、通常の汎用言語として考えた場合は、大文字と小文字は昨今の流れでは逆転している。
大文字小文字を逆転させた処理系を作成し、実際に使ってみることで、起きる問題をここで取り上げて検討してみたい。

変数名を小文字にするということは、

    add(A,B,R) :- R is A + B.
    data(R) :- R = data(1,2).
    zero :- nl.
を

    add(a,b,r) :- r is a + b.
    data(r) :- r = data(1,2).
    zero() :- nl().

と書けるようにしたい。
問題は述語をどうするのかである。小文字でかけることにすると、変数名とアリティ０の述語の区別がつかなくなる。
アリティゼロは、()を後ろに付けなくてはいけないことにすれば解決できそうである。

## セミコロンを終端文字とする。language

    add(A,B,R) :- R is A + B;

などと書きたい。
論理積は|を使うことにする。こうするとメタな言語として|演算子を自優につかえなくなる問題が別に出てくる。
Prologはメタな言語で言語を作って使う言語であると考えると、一見、セミコロンがOrの代わりのほうが良い用に思える。
しかし、セミコロンのある式でもf(a;b)と書けば、a;bのような式は扱うことが可能だ。
こうなれば、より一般的な言語に近づけると思う。
