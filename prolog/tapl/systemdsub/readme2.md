[The Essence of Dependent Object Types](https://infoscience.epfl.ch/record/215280/files/paper_1.pdf) の翻訳

# 2. System D<:

	構文

	x, y, z          変数
	v ::=            値
	　{A=T}          型タグ
	　λ(x:T)t       ラムダ
	s, t, u ::=      項
	　x              変数
	　v              値
	　x y            関数適用
	　let x = t in u let式

	S,T,U ::=        型
	  ⊤              top型
	　⊥             bottom型
	　{A:S..T}       型宣言
	　x.A            型射影
	　∀(x:S)T       依存関数

	評価規則 t ---> t
	        let x = v in e[x y] ---> let x = v in e[[z := y]t] if v=λ(z:T)t
	             let x = y in t ---> [x::=y] t
	let x = let y = s in t in u ---> let y = s in let x = t in u
	                       e[t] ---> e[u]                      if t ---> u
	                                 where e::=[] | let x = [] in t | let x = v in e

	                                 図1. System D<:

図1は我々のSystem D<: の式を要約したものです。
これらの項言語は本質的にラベル`A`と型`T`が関連づいている型タグ`{A=T}`の値の形式が1つ追加されたラムダ計算です。
現時点では、我々は一つの型ラベルだけが必要で、`A`はわずか1つの名前でアルファベット上の範囲とみなすことができます。
これは、後に一般化されます。

----

我々の説明は二つの側面でRompfとAmin（2015）とは異なります。
まず、項はA正規形[A-normal form](https://en.wikipedia.org/wiki/A-normal_form "A-normal form")に制限されています。
これは、すべての中間値はlet束縛の中で抽象化されています。(訳注: A正規形は関数適用の項に変数のみを用います。)
次に、ビッグステップ評価とは対照的に、評価規則はスモールステップ簡約関係で表されます。
簡約は完全な置換の代わりに唯一の変数/変数のリネームを使用しています。
置換ステップによってコピーされる代わりに、値はそれらのlet束縛にとどまります。
これは、call-by-need ラムダ計算[(Ariola et al., 1995)](https://pdfs.semanticscholar.org/2c7d/7e94298797ab0b9fb4ce6df957474da65b6b.pdf)に使用される技術に類似しています。

(訳注：評価文脈evaluation contextを使って、call-by-needの評価規則を記述した、Standard call-by-need reductionに似ています。

	Syntactic Domains

	Variables           x,y,z
	Values              V,W   ::= λx.T
	Terms               S,T,U ::= V | T U
	Answers             A,Ai  ::= λx.T | let x = T in A
	Evaluation Contexts E,Ei  ::= [] | E T | let x = T in E | let x = E0 in E1[x]

	Standard Reduction Rules

	(Is) (λx.T) U                        -> let x = U in T
	(Vs) let x = V in E[x]                -> let x = V in E[V]
	(Cs) (let x = S in A) U               -> let x = S in A U
	(As) let y = (let x = S in A) in E[y] -> let x = S in let y = A in E[y]

<center>Standard call-by-need reduction</center>

)

----
我々は全体を通して[Barendregtの変数規約](http://www21.in.tum.de/~berghofe/papers/CADE2007.pdf "Barendregt’s Variable Convention")を使用しています。
例えば、３つ目の評価ルールでは、ネストしていないlet束縛で、我々は適切にそれが最終的に項`u`で捕捉されないようにスコープを変更する変数`y`をα変換できることを前提としています。

----

	型付け規則 Γ ⊢ t : T

	Γ,x :T, Γ’ ⊢ x : T           (Var)

	Γ ⊢ t : T   Γ ⊢ T <: U
	———————————————— (Sub)
	Γ ⊢ t : U

	Γ,x :T ⊢ t : U   x ∉ fv(T)
	———————————————— (All-I)
	Γ ⊢ λ(x:T)t:∀(x:T)U

	Γ ⊢ x : ∀(z:S)T   Γ ⊢ y : S
	———————————————— (All-E)
	Γ ⊢ x y:[z::=y]T

	Γ ⊢ t : U   Γ,x:T ⊢ u:U
	x ∉ fv(U)
	———————————————— (Let)
	Γ ⊢ let x = t in u:U

	Γ ⊢ {A=T}:{A:T..T}             (Typ-I)

図1のタイプの割り当てルールは単純依存型付け規則を定義します。
ラムダ抽象は、依存関数型`∀(x:S)T`を持ちます。
これは、LF (Harper et al., 1993)の依存積(Dependent product)`Π(x:S)T`のようなものですが、一般的ではない項である制限変数`x`は唯一の他の変数をインスタンス化することができます。
型タグは`{A : S..U}`の形式の型を持ち、下有界が`S`かつ上有界が`U`である`A`でラベル付けられた型を表します。
一つの特定の型を参照する型タグは`{A : T..T}`のように、下限と上限を一致させることによって表現されます。
型タグを参照している変数`x`の型は、型の射影`x.A`で取り出すことができます。

----

	部分型付け規則 Γ ⊢ T <: T

	Γ ⊢ T <: ⊤           (Top)
	Γ ⊢ T <: ⊥           (Bot)
	Γ ⊢ T <: T           (Refl)

	Γ ⊢ S <: T   Γ ⊢ T <: U
	———————————————— (Trans)
	Γ ⊢ S <: U

	Γ ⊢ x : {A : S..T}
	———————————————— (<:-Sel)
	Γ ⊢ S <: x.A

	Γ ⊢ x : {A : S..T}
	———————————————— (Sel-<:)
	Γ ⊢ x.A <: T

	Γ ⊢ S2 <: S1
	Γ, x : S2 ⊢ T1 <: T2
	———————————————— (All-<:-All)
	Γ ⊢ ∀(x:S1)T1 <: ∀(x:S2)T2

	Γ ⊢ S2 <: S1 Γ ⊢ T1 <: T2
	———————————————— (Typ-<:-Typ)
	Γ ⊢ {A:S1..T1} <: {A:S2..T2}

図1のサブタイプのルールは、先行して`S <: T`型間の（Reful 反射）及び（Trans トランス）のルールを定義します。
これらは、`⊤`と`⊥`最大と最小のタイプ（Top）、（Bot）を明示し、
その下限(<:-Sel)とその上限(Sel-<:)のサブタイプの型の射影のスーパータイプ`x.A`を作ります。
さらに、標準的な共同/反変サブタイプの関係は、関数型(All-<:-All)とタグ付けされた型(Typ-<:-Typ)のペアの間に導入されました。

----

我々が3章で見るように System D<: は、System F<: をエンコードすることができます。
しかし、 System F<: とは異なり、 System D<: は、型変数を持っていません。
代わりに、`{A = T}` のような型定義は、型 `{A : T..T}` のファーストクラス値です。
依存関数と組み合わせることで、これらの経路依存型は、ポリモーフィズムのような型変数のイディオムを表現することができます。
例えば、System F<: の多相的な恒等関数は：

	⊢ Λ(α <: ⊤).λ(x : α).x : ∀(α <: ⊤).α → α

であり、System D<:では以下のようになります:

	⊢ λ(a : {A : ⊥..⊤}).λ(x : a.A).x : ∀(a:{A : ⊥..⊤})∀(x:a.A)a.A

-----

System F<: と同様、我々はいくつかの型に多相的な恒等関数を適用することができるように、`T`を用いて`T`上の恒等関数を取得します：

	⊢ let f =... in let a = {A = T} in f a : ∀(x:T)T

サブタイプの役割は本質的に:

（1）型 `{A：T..T}` の引数は型 `{A:⊥..⊤}`のパラメータを使用することが可能であり、
（2）依存結果型(dependent result type) `∀(x:a.A)a.A` は`T <: a.A <: T` であるため `∀(x:T)T` に変換することができます。

## 2.1 例: 依存 Sums

System F における存在型のものと同様の符号化を通じて、依存 sums は 依存関数を使ってエンコードできます。

	                   Σ(x : S)T ≡ ∀(z :{A : ⊥..⊤})∀(f :∀(x:S)∀(y :T)z.A)z.A
	    pack [x, y] as Σ(x : S)T ≡ λ(z :{A : ⊥..⊤})λ(f :∀(x:S)∀(y :T)z.A)f x y
	unpack x : S, y : T = t in u ≡ let z1 = t in let z2 = {A = U} in
	                                let z3 = (λ(x:S)λ(y :T)u) in
	                                let z4 = z1 z2 in z4 z3
	                         z.1 ≡ unpack x : S, y : T = z in x
	                         z.2 ≡ unpack x : S, y : T = z in y

ここで、`U`は`u`の型です。
関連する、許容サブタイピングと型付け規則は導出が容易であり、付録A.1に記載されています。

以下に注意してください:

1. `u`の型`U`内で`x`と`y`が自由に現れない場合、`unpack x, y = t in u`を経てunpackingは、許可されています。
2. 同様に、`T`内に`x`が自由に現れない場合は第2の射影演算子ー`.2`にのみ使用することができます。

これらの制限は驚きとして来ることがあります: 彼らは、System F/F<:で存在型に課せられた衛生条件に似ていながら,彼らは（完全に）依存型付け言語に依存sumsには適用されません。
そのような言語では、バインドされた名前`x,y`は`U`内の`x`と`y`の出現のための射影`t.1`および`t.2`を置換することによりunpack文全体の型へ漏れるのを防止することができます。
`[x := z.1]T`となる第2の射影`z.2`の戻り値の型についても同様です。
型は変数だけに依存する可能性があるため、残念ながら、このような置換はD<: で禁止されており、（`z.1`または`t.2`のような）任意の項とは対照的です。
同じ理由で、let式の型付け規則（Let）は、同様の衛生条件を備えています。
最後に、そのような操作は、System F/F<:における存在型に存在していないのに対し、上記の符号化は、`-.1`を介した「存在証明」の無制限の射影を可能にすることに注意してください。

# 3 D<: 内への F<: の埋め込み

System D<: は最初F<: の一般化として登場し、型ラムダから項ラムダと型パラメータから型タグをマップし、そしてF<: のビッグステップ評価の幾つかの制限を取り除きました(Rompf and Amin, 2015)。
我々は以下でこの対応を明示的にします。
型変数`X`から項変数`xX`に単射の写像を選びます。
以下では、Xの添え字で書かれていない任意の変数名は、そのマッピングの範囲外であると仮定されています。
F<:型と項からD<:型と項への翻訳*を次のように定義してみましょう。
(t*の定義は、新鮮な名前`x, X /∈ fb(t)`の可算供給を前提としています。)

	            X∗ = xX.A
	            ⊤∗ = ⊤
	     (T → U)∗ = ∀(x:T∗)U∗
	(∀(X <: S)T)∗ = ∀(xX :{A : ⊥..S∗})T∗

	            x∗ = x
	 (λ(x : T)t)∗ = λ(x : T∗)t∗
	(Λ(X <: S)t)∗ = λ(xX : {A : ⊥..S∗})t∗
	        (t u)∗ = let x = t∗ in let y = u∗ in x y            x, y fresh
	       (t[U])∗ = let x = t∗ in let yY = {A = U∗} in x yY    x, Y fresh

`*`の像ではない D<:項があることに注意してください。
例は`λ(x : {A:⊤..⊤})x`です。
次のように型付けコンテキストはポイント単位で変換されます:

	(X <: T)∗ = xX : {A : ⊥..T∗}
	 (x : T)∗ = x : T∗

定理1. もしも`Γ |-F S <: T` ならば `Γ∗ |-D S∗ <: T∗`。

証明.
証明はF<:のサブタイプの導出の単純な帰納法によります。
唯一の非自明なケースは (Var) かつ（SEL-<:) から、以下の型変数の部分的型付けです。

	Γ∗, xX : {A : ⊥..T∗}, Γ0∗ |- xX : {A : ⊥..T∗}
	--------------------------------------------------- (Sel-<:)
	Γ∗, xX : {A : ⊥..T∗}, Γ0∗ |- xX.A <: T∗

定理2. もしも`Γ |-F t : T` ならば `Γ∗ |-D t∗ : T∗`。

証明 (スケッチ).
証明は(System F) 型付け導出に関する帰納法によるものです。
包摂のためのケースは、部分型付けの保存からすぐに求まります。
唯一残っている興味深い例は、付録A.2に詳細に記載されている型と項の適用です。

# 参考文献

http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html
