# FTDOP5

  マクロの検索には時間がかかります。
  そこで、マクロの検索を早めるため、マクロ用構文を用意し、高速化します。
  具体的には、@というマクロ演算子を用いて、式をくくり、そこをマクロ展開します。

    @mac(('a ** 'b))a*b;
    @mac(mul('a,'b))a*b;
    (@(11111 ** 11111) + @mul(11111, 11111)) / 2

  例えばこのプログラムは、マクロを2つ定義し、マクロを実行しています。
  マクロが何処にあるかは一目瞭然です。

  マクロの検索は、@の中味しか検索しないので、検索が高速です。
  全ての構文要素に対して、マクロのマッチングを行っていたのに対して、@にのみマッチするようにしたので、よりマクロの展開が高速になりました。
  unapplyも使っていないので、より理解もしやすいはずです。

## プラグイン

  ftdop5ではプラグインを登録して使う事が出来ます。
  プラグインには、関数プラグインとマクロプラグインがあります。

    package mul

    import ftdop5._

    object plugin {
      fun("mul"){case((a:Int,",",b:Int),_) =>
          a * b
      }
      mac(("test","(",Symbol("a"),")")){ case (e:Env) =>
          e("a").asInstanceOf[Int] * 100
      }
    }

  使い方

    @load(mul)

    @test(10)+mul(2,3)

  @loadマクロで動的に、scalaで書いたマクロを読み込み、マクロを登録します。
  インタプリタなのに、何故動的にコンパイラマクロを読み込むのかというと、仕組みを作ってみたかったからです。