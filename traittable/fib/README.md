# Fib 40 bench

| language | fib | object | trait | trait 2d | trait opt | traitid| traitid opt|
| --- | ---- | ---- | --- | ---- | --- | --- |
| g++ -O3 | 474ms | 1,031ms | 1,220ms | 1399ms | 926ms | 1,062ms | 861ms|
| Java | 627ms | 1,110ms | 1,576ms |     | | 1,781ms | 1,341ms | 
| Node | 2,085ms | 3,754ms |   |   | | | |
| Ruby | 23,380ms | 121,465ms | | | | | |
| Rust --opt-level=3| 548ms | 609ms | | | | | |
| Rust -O| 550ms | 1,032ms | | | | | |
| Rust | 1,355ms | 3,927ms | | | | | |
| ocamlopt | 771ms | 13,791ms | | | | | |
| ocamlc | 6,516ms | 49.043ms | | | | | |
| gcc fib.m -O3 -fobjc-arc| 474ms | 151,031ms | | | | | |


## traitテーブル

Rustのトレイトは後からクラスを拡張出来て便利です。
しかし、実装は難しそうです。
出来れば簡単にそこそこ、高速に動く仕組みが欲しい所です。


そこで、ここでは構造体にidを付けて、トレイト１つにつき１つの配列を持たせて、
トレイトを実装するとトレイトの配列の構造体idの箇所にアドレスを書き込む方式を提案します。

この方式を用いれば、比較的高速で拡張性の高い型システムを実現出来ます。
トレイトを使う事でメソッド毎にテーブルを作らずにすみます。


この方式は単純で高速ですが、弱点はトレイトが増え、構造体が増えるとテーブルサイズが巨大になってしまう事です。
構造体数がSで、トレイト数がTとすると、S*T*CPUBIT/8 バイト のメモリを消費します。
構造体にメソッドが追加されればトレイトは必要になるとするとかなり大きな物になってしまいます。


## 2次元traitテーブル

テーブルサイズが大きくなりすぎる事の１つの対策が２次元にテーブルを分ける事です。
OSのメモリ管理はページングを行う事により、物理メモリを全てに割り当てる事無く、広大なメモリ空間にメモリを割り当てる事が出来ます。
同様の仕組みを取り入れる事で、テーブルサイズの縮小を行います。
関数呼び出しのオーバーヘッドは若干増えますが、メモリサイズを抑える事が出来ます。

## 範囲指定 2次元traitテーブル

単純な2次元のtraitテーブルでは、１ページのサイズをまとめて取る為、１つの実装の為にページサイズ分必要になってしまいます。
64bitCPUで8byteのデータの為にページサイズが256なら4kbyteも使用する事になります。
これは無駄です。
開始アドレスと終了アドレスを持つ事でこの問題を解決出来るでしょう。
たとえば、idが65536の場合はページnoは 256で、ページ内のindexNoは0です。トレイトはこれしか扱わないのであれば

ページ用の配列のサイズは8byteで開始ページは256、終了ページは257としましょう。ページ用の配列のアドレスはメモリの256*8だけマイナスしておきます。
ページ内の配列のサイズも8byteで開始Noは0で終了Noは1とします。

これで大部分の殆ど誰も使わないトレイトは小さいサイズで済ませる事が出来ます。


## テーブル拡張のオーバーヘッド対策

先にトレイトのサイズだけ把握する。具体的には、最初はリストに溜め込む。
メイン関数が始まったら、もう拡張しないことが確定するのでまとめてメモリ確保する。

