# 多相型推論+型クラス

[poly\_mono\_tclass](../poly_mono_tclass)では多相型推論へ単相の型クラスを導入は出来ましたが、関数で一般化する事は出来ません。
ここでは、型クラスを受け取る関数を一般化する事を考えます。
多相型システムでは、let式は、名前にバインドされる型が決定出来ない場合、決定出来ない型は一般的な型引数とみなし、型引数と型の対を型スキームと呼びます。
型クラスを一般化するには、型スキームに型クラスの制約を追加します。let式の型スキームの型パラメータに型クラスの制約があれば、型クラスを表す辞書データを上位から受け取る式に変換します。上位から受け取った辞書データは変数が具体化された箇所へ受け渡します。型クラスの辞書を受け渡す事を辞書パッシングと呼びます。型クラスが存在する言語の式の構文木に型クラスの辞書は表れませんが、変換後の型クラスのない言語の式には辞書が現れます。具体的な例は既に示した通りです。

### 辞書パッシング

letでは一般化の処理が行われますが、型が決められない一般的な型は、パラメータとして型スキームの１つの要素として表れます。
一般的な型は複数の引数で共有されます。
型に付く型クラスの制約もletによって一般化されます。
型スキーム内の型パラメータに関係する、型クラス制約は型パラメータごとに１つずつ必要です。
型クラスの制約は辞書としてエンコードされます。ネストした一般的な関数では型クラスの制約は次から次へと引き渡されます。これを辞書パッシングといいます。
型クラス制約のある式から型クラスのない式への変換は辞書パッシングのパラメータを追加し、必要な関数に引き渡す事で変換出来ます。
let式があったら先に型パラメータを求め、型パラメータごとにその型パラメータに関連する型クラス制約のリストを作る事で、型クラス制約の抽出処理を行う事が出来ます。

### 型クラス制約の単一化

型クラス制約は単一化された型変数すべての型制約の総和です。例えば、Num t1 => t1, Show t2 => t2のときにt1とt2の型が単一化された場合を考えます。
このとき置換リストはsubst[(t1,t2)]、型クラス制約リストはpred[(t1,Num);(t2,Show)]です。
このとき、t1はt2に全て置き換えられます。substを実行する関数を実行すると型はプレーンな型に変換されるとすると、型クラスの制約リストは一度、substを実行すればプレーンな型クラス制約に置き換える事が出来ます。

### 型推論時処理と、プレースホルダと、プレースホルダの置き換え処理

単相の処理でもオーバーロードされた変数を参照して具体化する時点でプレースホルダに置き換える必要がありました。
多相的にする場合let式の値にバインドする式を包むプレースホルダを置きます。let式の型があれば、単一化後はプレーンな型を求める事が出来て、型が決まらない型は型パラメータとして型スキームを求める事が出来ます。さらに、型スキームから型クラスの制約を求められます。型クラスの制約は関数のパラメータとして右辺の関数の先頭につけることが出来ます。
型クラスの辞書の変数は環境中に型変数に対応するオーバーロードされた型として処理を進めます。

### let rec

let recは再帰的に変数を用いる事ができるので、型推論時には新しい型変数を先に割り当てて推論します。
let recで定義された変数は型クラス制約があるかどうか最初は分からないので、型クラス制約があるものとみなしlet recで定義された変数はプレースホルダに置き換え、オーバーロードされた関数として環境に保存します。型推論が終われば、型が確定するのでプレースホルダ内の型も決定できます。

### 変数参照のプレースホルダの置き換え

この処理は基本的に単相の処理と変わりません。
型に対応する環境を見てその変数を関数に受け渡すようにします。
ただし、let recによって場合によってはオーバーロードされていない値がプレースホルダとして使用される可能性があります。
型クラスの制約がなければ、型クラスがない場合は受け渡しません。

### 型クラス制約の求めかた

型クラス制約のある関数を参照したときに、一般的な型に型クラス制約を付加します。型が決まっている場合は型クラスの制約は不要なので削除する必要があります。型クラス制約のある関数をコピーした場合、型も型クラス制約付きになります。

	let f x y =
		let (a:Num t=> t) = (add: Num t=> t) in
		a x y

は

	let f = fun num -> fun x -> fun y ->
		let a = fun num -> add num in
		a num x y

にエンコードされます。aは一般化され、numはパッシングされるべきものであるから、aの型クラス制約はaddから分かるのでよい。


### let recの型制約

型クラスの制約は、型変数の１つから型クラス名へのマップで表す事が出来ます。
let rec式の型の型クラス制約はlet rec中で決定できないのでlet recで指定された変数の型を参照する事で作られる型もまた型制約を持つべきであるにもかかわらず、型制約を持たない可能性があります。

	let rec f x y =
		let a = f in
		if y = y then add y y else
		add x (a y y)

以上の式のaの型制約は1回目のトラバースでは分かりません。xとyにaddの制約がつくのと、xとyの型は同じで、ある事と、返り値の型もadd y yから同じである事が分かり、Num a => a -> a -> aがfの型でaの型もNum a => a -> a -> aである事が分かるのですが、aの型はfを具体化したあと一般化されるはずであり、fの型が決まっていないのに、具体化されて、一般化されるので型変数が別になり、別な型変数同士が単一化されないとなると型制約が伝搬されず１回のトラバースでは、型制約を解消出来ない事になってしまいます。1回のトラバースでは完全に型制約を解消できないので、型制約は型から求まる曖昧な制約が混じったリストで表す必要があります。let recの変数は曖昧なので、型クラス制約も曖昧であるので、型変数から作られる曖昧な型クラス制約を持つと表して返せば、良い訳です。

	let rec f x y =
		let (a : ? => t1 -> t2 -> t3) = (f : ? => t1 -> t2 -> t3) in
		if y = y then add y y else
		add x (a y y)

以上の式は以下の式に書き換え可能です。

	let rec f num x y =
		let a num = f num in
		if y = y then add num y y else
		add num x (a num y y)

aの型はfと同じですが、fの型制約はaが表れた時点ではわかりません。プレースホルダをおくのはよいのですが、制約の集合にaの型から求めるというプレースホルダを入れる必要があります。

求まった型クラス制約のリストと型変数の代入のリストから、１つの型と型クラスの制約リストが求まります。最後にプレースホルダを置き換える処理を行えば変換処理が出来そうです。

制約のリストは例えば["t1",CName "Num";"t2",TName "t1"]のように表せる。そしてこれを解決すると
["t1","Num"; "t2","Num"]になるのです。

